<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>C&W Story Tracker</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='mobile.css') }}" media="(max-width:760px)">
    <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='ccp.ico') }}">
    <style>
      /* Tooltip used for truncated titles on hover */
      .title-tooltip {
        position: fixed;
        background: rgba(0,0,0,0.88);
        color: #fff;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 0.95rem;
        line-height: 1.3;
        pointer-events: none;
        z-index: 2500;
        white-space: normal;
        max-width: 70vw;
        box-shadow: 0 6px 18px rgba(0,0,0,0.35);
        display: none;
      }

      /* Status Timeline Modal Styles */
      .status-modal {
        display: none;
        position: fixed;
        z-index: 3000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        align-items: center;
        justify-content: center;
      }

      .status-modal-content {
        background-color: #fff;
        padding: 30px 40px;
        border-radius: 12px;
        max-width: 600px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        overflow-x: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        position: relative;
        box-sizing: border-box;
      }

      .status-modal-close {
        float: right;
        border: none;
        background: transparent;
        color: red;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }

      .status-modal-close:hover {
        background: transparent;
        color: red;
      }

      .status-modal h3 {
        margin: 0 0 20px 0;
      }

      .status-timeline {
        position: relative;
        padding-left: 50px;
      }

      .status-timeline-item {
        position: relative;
        padding-bottom: 25px;
      }

      .status-timeline-item:last-child {
        padding-bottom: 0;
      }

      .status-timeline-line {
        position: absolute;
        left: -35px;
        top: 0;
        bottom: 0;
        width: 3px;
        background: #e0e0e0;
      }

      .status-timeline-line.active {
        background: #4CAF50;
      }

      .status-timeline-dot {
        position: absolute;
        left: -43px;
        top: 3px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #e0e0e0;
        border: 3px solid #fff;
        box-shadow: 0 0 0 2px #e0e0e0;
        z-index: 1;
      }

      .status-timeline-dot.active {
        background: #4CAF50;
        box-shadow: 0 0 0 2px #4CAF50;
      }

      .status-timeline-dot.completed {
        background: #4CAF50;
        box-shadow: 0 0 0 2px #4CAF50;
      }

      .status-timeline-status {
        font-weight: 600;
        font-size: 16px;
        color: #333;
        margin-bottom: 8px;
        cursor: pointer;
        display: inline-block;
        transition: color 0.2s;
        word-wrap: break-word;
        overflow-wrap: break-word;
        max-width: 100%;
      }

      .status-timeline-status:hover {
        color: #4CAF50;
      }

      .status-timeline-status.active {
        color: #4CAF50;
      }

      .status-timeline-meta {
        font-size: 13px;
        color: #666;
        margin-top: 5px;
        line-height: 1.5;
        word-wrap: break-word;
        overflow-wrap: break-word;
        max-width: 100%;
      }

      .status-timeline-meta div {
        margin: 2px 0;
      }

      .status-button {
        padding: 6px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #fff;
        color: #000;
        cursor: pointer;
        font-size: 1rem;
        font-weight: normal;
        font-family: inherit;
        width: 110px;
        min-width: 110px;
        max-width: 110px;
        box-sizing: border-box;
        text-align: left;
        transition: all 0.2s;
        overflow: hidden;
        text-overflow: clip;
        white-space: nowrap;
        display: inline-block;
      }

      .status-button:hover {
        background: #f5f5f5;
        border-color: #ccc;
      }

      tr.published .status-button {
        color: #999;
        background: #E5E5E5;
      }

      select:disabled {
        cursor: default;
      }
    </style>
</head>
<body>

<div class="user-box">
  <span class="greeting">Hello, {{ current_user.name }}!</span>
      {% if current_user.is_authenticated and current_user.email in ALLOWED_EMAILS %}
        <a href="{{ url_for('manage') }}" class="manage-form">
            <button type="button" class="settings-btn">⚙</button>
        </a>
    {% endif %}
  <form action="{{ url_for('logout') }}" method="get">
    <button type="submit">Logout</button>
  </form>
</div>



    <div style="display: flex; justify-content: center; align-items: center;">
    <h1 style="display: inline;"><a href="https://www.ccpstudentnews.org" style="font-family: 'Brush Script MT'; text-decoration: none; color: #222; font-size: 45px;">Cardinal and White&nbsp; </a></h1><h1 style="display: inline;">Story Tracker</h1>
    </div>
   

    <form method="POST" class="typ" action="/add">
        <input type="text" name="title" placeholder="Article Title" required>
        <input type="text" name="author" placeholder="Author Name" required>
        <select id="cat" name="cat">
          <option value="F">-- Type --</option>
          <option value="F">Features</option>
          <option value="N">News</option>
          <option value="O">Opinion</option>
          <option value="S">Sports</option>
        </select>
        <input type="date" name="deadline">
        <button type="submit">Add Article</button>
    </form>


<table>
  <thead>
    <tr>
      <th class="drag-handle"> </th> 
      <th class="cat">Type</th>
      <th class="title">Title</th>
      <th class="author">Author</th>
      <th class="status">Status</th>
      <th class="editor">Editor</th>
      <th class="deadline">Deadline</th>
      <th class="filescol">Files</th>
      <th class="actions">Actions</th>
    </tr>
  </thead>
  <tbody id="articles-tbody">
  {% for article in articles %}
    <tr id="row-{{ article.id }}" data-id="{{ article.id }}" class="{% if article.status == 'Published' %}published{% endif %}">
      <td class="drag-handle" style="cursor: grab;">☰</td>
      <td class="cat">
        <select onchange="updateCat({{ article.id }}, this.value)" {% if article.status == 'Published' %}disabled{% endif %}>
          <option value="F" {% if article.cat == 'F' %}selected{% endif %}>F</option>
          <option value="N" {% if article.cat == 'N' %}selected{% endif %}>N</option>
          <option value="O" {% if article.cat == 'O' %}selected{% endif %}>O</option>
          <option value="S" {% if article.cat == 'S' %}selected{% endif %}>S</option>
      </td>
      <td class="title">{{ article.title }}</td>
      <td class="author">{{ article.author }}</td>
            <td class="status">
                <button class="status-button" onclick="openStatusModal({{ article.id }}, '{{ article.status }}')">
                    {{ article.status }}
                </button>
                <button class="status-color {% if article.status_color == 'red' %}red{% elif article.status_color == 'yellow' %}yellow{% else %}white{% endif %}" aria-label="Status Color" onclick="cycleStatusColor({{ article.id }}, event)"></button>
            </td>
      <td class="editor">
  <select onchange="updateEditor({{ article.id }}, this.value)" {% if article.status == 'Published' %}disabled{% endif %}>
    <option value="">-- Select --</option>
    <option value="Copley" {% if article.editor == 'Copley' %}selected{% endif %}>Copley</option>
    <option value="Lewis" {% if article.editor == 'Lewis' %}selected{% endif %}>Lewis</option>
  </select>
</td>

      <td class="deadline" data-deadline="{{ article.deadline }}">{{ article.deadline }}</td>

      <!-- Files column -->
      <td class="filescol">
        <button class="file-icon-btn" onclick="openFileManager({{ article.id }})">Files</button>
      </td>

      <!-- Actions column -->
      <td class="actions">
        {% if article.status == 'Published' %}
            <button onclick="markComplete({{ article.id }})" style="color:green;">Mark Complete</button>
        {% else %}
            <button onclick="toggleEdit({{ article.id }})" id="edit-btn-{{ article.id }}">Edit</button>
            <button onclick="deleteArticle({{ article.id }})" style="color:red;">Delete</button>
        {% endif %}
    </td>

    </tr>
  {% endfor %}
  </tbody>
</table>



<div id="fileManagerModal" class="modal" aria-hidden="true">
  <div class="modal-content">
    <button type="button" class="close" aria-label="Close" onclick="closeFileManager()">×</button>

    <h3>Files</h3>

    <ul id="fileList" class="file-list"></ul>
    <div class="upload-section">
      <form id="uploadForm" class="typ" enctype="multipart/form-data">
        <input type="file" name="file" id="fileInput" required />
        <button type="submit">Upload</button>
      </form>
    </div>
  </div>
</div>

<!-- Status Timeline Modal -->
<div id="statusModal" class="status-modal" aria-hidden="true">
  <div class="status-modal-content">
    <button type="button" class="status-modal-close" aria-label="Close" onclick="closeStatusModal()">×</button>
    <h3>Status</h3>
    <div class="status-timeline" id="statusTimeline">
      <!-- Timeline items will be dynamically inserted here -->
    </div>
  </div>
</div>

<div class="footerbut" style="display: flex; justify-content: center; align-items: center; margin: 20px; gap: 15px;">
    <a href="{{ url_for('archived') }}">View Archived Articles</a>

    <a href="{{ url_for('calendar') }}">
        <img src="{{ url_for('static', filename='calendar.png') }}" alt="Calendar" style="width: 18px; height: 18px;">
    </a>
</div>



<script src="https://cdn.socket.io/4.7.2/socket.io.min.js" crossorigin="anonymous"></script>


<script>
const socket = io();
var currentArticleId = null;
var currentStatusArticleId = null;

// Status Modal Functions
const STATUS_OPTIONS = ['Not Started', 'In Progress', 'Needs Edit', 'Edited', 'Published'];

function openStatusModal(articleId, currentStatus) {
    currentStatusArticleId = articleId;
    const modal = document.getElementById('statusModal');
    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');
    loadStatusHistory(articleId);
}

function closeStatusModal() {
    const modal = document.getElementById('statusModal');
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden', 'true');
    currentStatusArticleId = null;
}

window.addEventListener('click', e => { 
    if (e.target.id === 'statusModal') closeStatusModal(); 
});

window.addEventListener('keydown', e => { 
    if (e.key === 'Escape' && document.getElementById('statusModal').style.display === 'flex') {
        closeStatusModal(); 
    }
});

async function loadStatusHistory(articleId) {
    const timeline = document.getElementById('statusTimeline');
    timeline.innerHTML = '<div style="text-align: center; padding: 20px;">Loading...</div>';
    
    try {
        const res = await fetch(`/status_history/${articleId}`);
        const data = await res.json();
        renderStatusTimeline(data.history, articleId);
    } catch (err) {
        timeline.innerHTML = '<div style="text-align: center; padding: 20px; color: #f44336;">Failed to load status history</div>';
        console.error('Failed to load status history:', err);
    }
}

function renderStatusTimeline(history, articleId) {
    const timeline = document.getElementById('statusTimeline');
    timeline.innerHTML = '';
    
    // Create a map of status to history entry
    const statusMap = {};
    history.forEach(h => {
        // Keep only the most recent entry for each status
        if (!statusMap[h.status] || new Date(h.timestamp) > new Date(statusMap[h.status].timestamp)) {
            statusMap[h.status] = h;
        }
    });
    
    // Get current status
    const currentStatusIndex = history.length > 0 ? 
        STATUS_OPTIONS.indexOf(history[history.length - 1].status) : -1;
    
    STATUS_OPTIONS.forEach((status, index) => {
        const item = document.createElement('div');
        item.className = 'status-timeline-item';
        
        const historyEntry = statusMap[status];
        const isActive = historyEntry && history[history.length - 1]?.status === status;
        
        // Status is completed if:
        // 1. It has a history entry, OR
        // 2. It's between the first completed status and current status (skipped but should show green)
        const isCompleted = historyEntry !== undefined;
        const isSkipped = !isCompleted && index > 0 && index < currentStatusIndex;
        const shouldShowGreen = isCompleted || isSkipped;
        
        // Create line
        const line = document.createElement('div');
        line.className = 'status-timeline-line';
        if (index < currentStatusIndex || shouldShowGreen) {
            line.classList.add('active');
        }
        
        // Create dot
        const dot = document.createElement('div');
        dot.className = 'status-timeline-dot';
        if (isActive) {
            dot.classList.add('active');
        } else if (shouldShowGreen) {
            dot.classList.add('completed');
        }
        
        // Create status label
        const statusLabel = document.createElement('div');
        statusLabel.className = 'status-timeline-status';
        if (isActive) {
            statusLabel.classList.add('active');
        }
        statusLabel.textContent = status;
        statusLabel.onclick = () => changeStatus(articleId, status);
        
        // Create meta info - only show if there's actual history entry (not skipped)
        const meta = document.createElement('div');
        meta.className = 'status-timeline-meta';
        
        if (historyEntry) {
            // The timestamp from server is in UTC but doesn't have Z suffix, so add it
            const utcTimestamp = historyEntry.timestamp.endsWith('Z') ? historyEntry.timestamp : historyEntry.timestamp + 'Z';
            const date = new Date(utcTimestamp);
            const dateStr = date.toLocaleString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
            
            meta.innerHTML = `
                <div><strong>Updated by:</strong> ${historyEntry.user_name}</div>
                <div><strong>Date:</strong> ${dateStr}</div>
            `;
        }
        
        item.appendChild(line);
        item.appendChild(dot);
        item.appendChild(statusLabel);
        if (historyEntry) {
            item.appendChild(meta);
        }
        
        timeline.appendChild(item);
    });
}

async function updateStatusTimelineInPlace(articleId) {
    try {
        const res = await fetch(`/status_history/${articleId}`);
        const data = await res.json();
        const history = data.history;
        
        // Create a map of status to history entry
        const statusMap = {};
        history.forEach(h => {
            if (!statusMap[h.status] || new Date(h.timestamp) > new Date(statusMap[h.status].timestamp)) {
                statusMap[h.status] = h;
            }
        });
        
        // Get current status
        const currentStatusIndex = history.length > 0 ? 
            STATUS_OPTIONS.indexOf(history[history.length - 1].status) : -1;
        
        // Update each timeline item in place
        const timeline = document.getElementById('statusTimeline');
        const items = timeline.querySelectorAll('.status-timeline-item');
        
        STATUS_OPTIONS.forEach((status, index) => {
            const item = items[index];
            if (!item) return;
            
            const historyEntry = statusMap[status];
            const isActive = historyEntry && history[history.length - 1]?.status === status;
            const isCompleted = historyEntry !== undefined;
            const isSkipped = !isCompleted && index > 0 && index < currentStatusIndex;
            const shouldShowGreen = isCompleted || isSkipped;
            
            // Update line
            const line = item.querySelector('.status-timeline-line');
            if (line) {
                if (index < currentStatusIndex || shouldShowGreen) {
                    line.classList.add('active');
                } else {
                    line.classList.remove('active');
                }
            }
            
            // Update dot
            const dot = item.querySelector('.status-timeline-dot');
            if (dot) {
                dot.classList.remove('active', 'completed');
                if (isActive) {
                    dot.classList.add('active');
                } else if (shouldShowGreen) {
                    dot.classList.add('completed');
                }
            }
            
            // Update status label
            const statusLabel = item.querySelector('.status-timeline-status');
            if (statusLabel) {
                statusLabel.classList.remove('active');
                if (isActive) {
                    statusLabel.classList.add('active');
                }
            }
            
            // Update meta
            const meta = item.querySelector('.status-timeline-meta');
            if (meta) {
                if (historyEntry) {
                    const utcTimestamp = historyEntry.timestamp.endsWith('Z') ? historyEntry.timestamp : historyEntry.timestamp + 'Z';
                    const date = new Date(utcTimestamp);
                    const dateStr = date.toLocaleString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        year: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    });
                    
                    meta.innerHTML = `
                        <div><strong>Updated by:</strong> ${historyEntry.user_name}</div>
                        <div><strong>Date:</strong> ${dateStr}</div>
                    `;
                    meta.style.display = 'block';
                } else {
                    meta.innerHTML = '';
                    meta.style.display = 'none';
                }
            }
        });
    } catch (err) {
        console.error('Failed to update status timeline:', err);
    }
}

async function changeStatus(articleId, newStatus) {
    try {
        // First, get the current history to check if we're reverting
        const historyRes = await fetch(`/status_history/${articleId}`);
        const historyData = await historyRes.json();
        const history = historyData.history;
        
        const currentStatusIndex = history.length > 0 ? 
            STATUS_OPTIONS.indexOf(history[history.length - 1].status) : -1;
        const newStatusIndex = STATUS_OPTIONS.indexOf(newStatus);
        
        // Check if we're reverting to a previous status
        if (currentStatusIndex > newStatusIndex) {
            // Check if the status we're reverting to already has history
            const hasHistory = history.some(h => h.status === newStatus);
            if (hasHistory) {
                const confirmed = confirm(`Are you sure you want to revert to "${newStatus}"?`);
                if (!confirmed) {
                    return;
                }
            }
        }
        
        const res = await fetch(`/update_status/${articleId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ status: newStatus })
        });
        
        const data = await res.json();
        if (data.success) {
            // Update the timeline in place without full rebuild
            await updateStatusTimelineInPlace(articleId);
            
            // Update the status button in the table
            const row = document.getElementById(`row-${articleId}`);
            if (row) {
                const statusBtn = row.querySelector('.status-button');
                if (statusBtn) {
                    statusBtn.textContent = newStatus;
                }
                
                // Update published class
                if (newStatus === 'Published') {
                    row.classList.add('published');
                } else {
                    row.classList.remove('published');
                }
                
                // Update disabled state of dropdowns
                const catSelect = row.querySelector('.cat select');
                const editorSelect = row.querySelector('.editor select');
                if (newStatus === 'Published') {
                    if (catSelect) catSelect.disabled = true;
                    if (editorSelect) editorSelect.disabled = true;
                } else {
                    if (catSelect) catSelect.disabled = false;
                    if (editorSelect) editorSelect.disabled = false;
                }
                
                // Update actions cell if needed
                const actionsCell = row.querySelector('.actions');
                if (newStatus === 'Published') {
                    actionsCell.innerHTML = `<button onclick="markComplete(${articleId})" style="color:green;">Mark Complete</button>`;
                } else {
                    actionsCell.innerHTML = `
                        <button onclick="toggleEdit(${articleId})" id="edit-btn-${articleId}">Edit</button>
                        <button onclick="deleteArticle(${articleId})" style="color:red;">Delete</button>
                    `;
                }
            }
        } else {
            alert('Failed to update status');
        }
    } catch (err) {
        console.error('Error updating status:', err);
        alert('Failed to update status');
    }
}

// Helper 
function addOrUpdateRow(data) {
    let row = document.getElementById(`row-${data.id}`);
    const currentStatus = row?.querySelector('.status-button')?.textContent || data.status;
    const currentEditor = row?.querySelector('.editor select')?.value;
    const currentCat = row?.querySelector('.cat select')?.value;

    if (!row) {
        const tbody = document.querySelector('table tbody');
        row = document.createElement('tr');
        row.id = `row-${data.id}`;
        tbody.appendChild(row);
    }

    row.dataset.id = data.id;

    row.innerHTML = `
        <td class="drag-handle" style="cursor: grab;">☰</td>
        <td class="cat">
            <select onchange="updateCat(${data.id}, this.value)" ${currentStatus === 'Published' ? 'disabled' : ''}>
                <option value="F" ${(currentCat || data.cat) === 'F' ? 'selected' : ''}>F</option>
                <option value="N" ${(currentCat || data.cat) === 'N' ? 'selected' : ''}>N</option>
                <option value="O" ${(currentCat || data.cat) === 'O' ? 'selected' : ''}>O</option>
                <option value="S" ${(currentCat || data.cat) === 'S' ? 'selected' : ''}>S</option>
            </select>
        </td>
        <td class="title">${data.title}</td>
        <td class="author">${data.author}</td>
        <td class="status">
            <button class="status-button" onclick="openStatusModal(${data.id}, '${currentStatus}')">
                ${currentStatus}
            </button>
            <button class="status-color ${ (data.status_color === 'red') ? 'red' : (data.status_color === 'yellow' ? 'yellow' : 'white') }" aria-label="Status Color" onclick="cycleStatusColor(${data.id}, event)"></button>
        </td>
        <td class="editor">
            <select onchange="updateEditor(${data.id}, this.value)" ${currentStatus === 'Published' ? 'disabled' : ''}>
                <option value="">-- Select --</option>
                <option value="Copley" ${(currentEditor || data.editor) === 'Copley' ? 'selected' : ''}>Copley</option>
                <option value="Lewis" ${(currentEditor || data.editor) === 'Lewis' ? 'selected' : ''}>Lewis</option>
            </select>
        </td>
        <td class="deadline">${data.deadline || ''}</td>
        <td class="filescol"><button class="file-icon-btn" onclick="openFileManager(${data.id})">Files</button></td>
      <td class="actions">
    ${
        currentStatus === 'Published'
        ? `<button onclick="markComplete(${data.id})" style="color:green;">Mark Complete</button>`
        : `
            <button onclick="toggleEdit(${data.id})" id="edit-btn-${data.id}">Edit</button>
            <button onclick="deleteArticle(${data.id})" style="color:red;">Delete</button>
          `
    }
    </td>


    `;

    // Update published class
    if (currentStatus === 'Published') row.classList.add('published');
    else row.classList.remove('published');
}

// Article Functions
function toggleEdit(articleId) {
    const row = document.getElementById(`row-${articleId}`);
    const editBtn = document.getElementById(`edit-btn-${articleId}`);

    if (editBtn.textContent === "Edit") {
        // Enter edit mode
        const title = row.querySelector('.title').textContent;
        const author = row.querySelector('.author').textContent;
        const deadline = row.querySelector('.deadline').textContent;

        row.querySelector('.title').innerHTML = `<input type="text" value="${title}" id="title-input-${articleId}">`;
        row.querySelector('.author').innerHTML = `<input type="text" value="${author}" id="author-input-${articleId}">`;
        row.querySelector('.deadline').innerHTML = `<input type="date" value="${deadline}" id="deadline-input-${articleId}">`;

        editBtn.textContent = "Done";
    } else {
        // Exit edit mode
        const newTitle = document.getElementById(`title-input-${articleId}`).value.trim();
        const newAuthor = document.getElementById(`author-input-${articleId}`).value.trim();
        const newDeadline = document.getElementById(`deadline-input-${articleId}`).value;

        fetch(`/update/${articleId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: newTitle, author: newAuthor, deadline: newDeadline })
        })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                row.querySelector('.title').textContent = newTitle;
                row.querySelector('.author').textContent = newAuthor;
                row.querySelector('.deadline').textContent = newDeadline;
                editBtn.textContent = "Edit";

                // Emit update
                socket.emit('article_updated', { id: articleId, title: newTitle, author: newAuthor, deadline: newDeadline });
            } else alert("Failed to save changes.");
        });
    }
}

// Status / Editor
function cycleStatusColor(articleId, event) {
    event.stopPropagation();
    event.preventDefault();

    const row = document.getElementById(`row-${articleId}`);
    if (row && row.classList.contains('published')) return;
    if (!row) return;
    const dot = row.querySelector('.status-color');
    if (!dot) return;

    const classes = ['white','red','yellow'];
    const current = classes.find(c => dot.classList.contains(c)) || 'white';
    const next = classes[(classes.indexOf(current) + 1) % classes.length];

    dot.classList.remove('white','red','yellow');
    dot.classList.add(next);

    fetch(`/update_status_color/${articleId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ color: next })
    }).then(res => {
        if (!res.ok) {
        
            dot.classList.remove('white','red','yellow');
            dot.classList.add(current);
            return res.json().then(j => { throw new Error(j.error || 'update failed'); });
        }
        return res.json();
    }).then(json => {
        if (json.success) {
            socket.emit('status_color_updated', { id: articleId, status_color: next });
        }
    }).catch(err => {
        console.error('Failed to update status color', err);
    });
}

function updateCat(articleId, cat) {
    fetch(`/update_cat/${articleId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ cat })
    }).then(res => res.json())
      .then(data => {
          if (!data.success) alert('Error updating category!');
          else socket.emit('cat_updated', { id: articleId, cat });
      });
}

function updateEditor(articleId, editor) {
    fetch(`/update_editor/${articleId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ editor })
    }).then(res => res.json())
      .then(data => {
          if (!data.success) alert('Error updating editor!');
          else socket.emit('editor_updated', { id: articleId, editor });
      });
}

// Delete Article 
function deleteArticle(articleId) {
    if (!confirm("Are you sure you want to delete this article?")) return;
    fetch(`/delete/${articleId}`, { method: 'POST' })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                const row = document.getElementById(`row-${articleId}`);
                if (row) row.remove();
                socket.emit('article_deleted', { id: articleId });
            } else alert('Error deleting article!');
        });
}

// File Manager
function openFileManager(articleId) {
    currentArticleId = articleId;
    const modal = document.getElementById('fileManagerModal');
    modal.style.display = 'block';
    modal.setAttribute('aria-hidden', 'false');
    loadFiles(articleId);
}

function closeFileManager() {
    const modal = document.getElementById('fileManagerModal');
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden', 'true');
    currentArticleId = null;
    document.getElementById('fileList').innerHTML = '';
    document.getElementById('uploadForm').reset();
}

window.addEventListener('click', e => { if (e.target.id === 'fileManagerModal') closeFileManager(); });
window.addEventListener('keydown', e => { if (e.key === 'Escape') closeFileManager(); });

function loadFiles(articleId) {
    const ul = document.getElementById('fileList');

    ul.innerHTML = '<li class="loading">Loading…</li>';

    fetch(`/files/${articleId}`)
        .then(res => res.json())
        .then(data => {
            ul.innerHTML = '';

            (data.files || []).forEach(f => {
                const li = document.createElement('li');
                li.id = `file-${f.id}`;
                li.innerHTML = `
                    <div class="file-actions">
                        <a href="/download_file/${f.id}" target="_blank">
                            <button class="download-btn">${f.filename}</button>
                        </a>
                        <button onclick="deleteFile(${f.id})" class="delete-btn">Delete</button>
                    </div>
                `;
                ul.appendChild(li);
            });
        })
        .catch(() => {
            ul.innerHTML = '<li class="error">Failed to load files</li>';
        });
}

document.getElementById('uploadForm').addEventListener('submit', async e => {
    e.preventDefault();
    if (!currentArticleId) return;

    const fileInput = document.getElementById('fileInput');
    if (!fileInput.files.length) return;

    const formData = new FormData(e.target);


    const uploadBtn = e.target.querySelector('button[type="submit"]');
    uploadBtn.disabled = true;
    uploadBtn.textContent = "Wait...";

    try {
        const res = await fetch(`/upload/${currentArticleId}`, {
            method: 'POST',
            body: formData
        });
        const data = await res.json();

        if (data.success) {
           
            fileInput.value = "";

          
            loadFiles(currentArticleId);
        } else {
            alert("Upload failed: " + (data.message || "Unknown error"));
        }
    } catch (err) {
        alert("Upload failed. Please try again.");
        console.error(err);
    } finally {
        uploadBtn.disabled = false;
        uploadBtn.textContent = "Upload";
    }
});


function deleteFile(fileId) {
    if (!confirm('Delete this file?')) return;
    fetch(`/delete_file/${fileId}`, { method: 'POST' })
        .then(res => res.json())
        .then(data => { if (data.success) document.getElementById(`file-${fileId}`).remove(); });
}

// Socket Listeners
socket.on('article_added', addOrUpdateRow);
socket.on('article_updated', data => {
    const row = document.getElementById(`row-${data.id}`);
    if (row) {
        row.querySelector('.title').textContent = data.title;
        row.querySelector('.author').textContent = data.author;
        row.querySelector('.deadline').textContent = data.deadline || '';
    } else addOrUpdateRow(data);
});
socket.on('status_updated', data => {
    const row = document.getElementById(`row-${data.id}`);
    if (row) {
        const statusBtn = row.querySelector('.status-button');
        if (statusBtn) {
            statusBtn.textContent = data.status;
        }

        row.classList.toggle('published', data.status === 'Published');

        // Update disabled state of dropdowns
        const catSelect = row.querySelector('.cat select');
        const editorSelect = row.querySelector('.editor select');
        if (data.status === 'Published') {
            if (catSelect) catSelect.disabled = true;
            if (editorSelect) editorSelect.disabled = true;
        } else {
            if (catSelect) catSelect.disabled = false;
            if (editorSelect) editorSelect.disabled = false;
        }

        // Update actions cell
        const actionsCell = row.querySelector('.actions');
        if (data.status === 'Published') {
            actionsCell.innerHTML = `<button onclick="markComplete(${data.id})" style="color:green;">Mark Complete</button>`;
        } else {
            actionsCell.innerHTML = `
                <button onclick="toggleEdit(${data.id})" id="edit-btn-${data.id}">Edit</button>
                <button onclick="deleteArticle(${data.id})" style="color:red;">Delete</button>
            `;
        }
        
        // If the status modal is open for this article, reload it
        if (currentStatusArticleId === data.id) {
            updateStatusTimelineInPlace(data.id);
        }
    }
});
socket.on('status_color_updated', data => {
    const row = document.getElementById(`row-${data.id}`);
    if (!row) return;
    const dot = row.querySelector('.status-color');
    if (!dot) return;
    dot.classList.remove('white','red','yellow');
    dot.classList.add(data.status_color || 'white');
});
socket.on('editor_updated', data => {
    const row = document.getElementById(`row-${data.id}`);
    if (row) row.querySelector('.editor select').value = data.editor;
});
socket.on('cat_updated', data => {
    const row = document.getElementById(`row-${data.id}`);
    if (row) row.querySelector('.cat select').value = data.cat;
});
socket.on('article_deleted', data => {
    const row = document.getElementById(`row-${data.id}`);
    if (row) row.remove();
});
socket.on('file_uploaded', data => { if (currentArticleId === data.articleId) loadFiles(currentArticleId); });
socket.on('file_deleted', data => { const li = document.getElementById(`file-${data.file_id}`); if (li) li.remove(); });

socket.on('article_archived', data => {
    const row = document.getElementById(`row-${data.id}`);
    if (row) row.remove();
});

socket.on('article_activated', data => {
    fetch(`/article/${data.id}`)
        .then(res => res.json())
        .then(article => addOrUpdateRow(article));
});

socket.on('update_article_order', (data) => {
    const tbody = document.querySelector('#articles-tbody');
    data.order.forEach(id => {
        const row = tbody.querySelector(`tr[data-id="${id}"]`);
        tbody.appendChild(row);
    });
});

</script>
<script>
function markComplete(articleId) {
    fetch(`/archive/${articleId}`, { method: 'POST' })
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                const row = document.getElementById(`row-${articleId}`);
                if (row) row.remove();
            } else {
                alert("Failed to archive article.");
            }
        });
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", () => {
    const tbody = document.getElementById("articles-tbody");

    // Initialize SortableJS
    new Sortable(tbody, {
        handle: ".drag-handle",  
        animation: 150,
        onEnd: () => {
            const order = [...tbody.querySelectorAll("tr")].map(row => row.dataset.id);
            
            fetch("/update_order", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ order })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    socket.emit("update_article_order", { order });
                }
            });
        }
    });
});
</script>

<!-- Tooltip script: show full title after a short hover delay -->
<script>
(function(){
  const HOVER_DELAY = 800; // ms
  let hoverTimer = null;
  let currentCell = null;

  const tooltip = document.createElement('div');
  tooltip.className = 'title-tooltip';
  document.body.appendChild(tooltip);

  function showTooltipFor(cell) {
    const text = cell.textContent?.trim();
    if (!text) return;
    tooltip.textContent = text;
    tooltip.style.display = 'block';

    requestAnimationFrame(() => {
      const rect = cell.getBoundingClientRect();
      const ttRect = tooltip.getBoundingClientRect();
  
      let top = rect.top - ttRect.height - 8;
      if (top < 8) top = rect.bottom + 8;

      let left = rect.left;
      if (left + ttRect.width > window.innerWidth - 8) {
        left = Math.max(8, window.innerWidth - ttRect.width - 8);
      }
      tooltip.style.top = `${Math.round(top)}px`;
      tooltip.style.left = `${Math.round(left)}px`;
    });
  }

  function hideTooltip() {
    tooltip.style.display = 'none';
    tooltip.textContent = '';
  }

  document.addEventListener('mouseover', (e) => {
    const cell = e.target.closest('td.title, th.title');
    if (!cell) return;
    
    const isOverflowing = cell.scrollWidth > cell.clientWidth;
    if (!isOverflowing) return;
    currentCell = cell;
    hoverTimer = setTimeout(() => {
      showTooltipFor(cell);
      hoverTimer = null;
    }, HOVER_DELAY);
  });

  document.addEventListener('mouseout', (e) => {
    const related = e.relatedTarget;
    const cell = e.target.closest('td.title, th.title');
    if (hoverTimer) { clearTimeout(hoverTimer); hoverTimer = null; }
    if (cell && (!related || !related.closest || !related.closest('td.title, th.title'))) {
      hideTooltip();
      currentCell = null;
    }
  });

  // also hide on scroll / resize / touch
  ['scroll','resize','touchstart'].forEach(evt => {
    window.addEventListener(evt, () => {
      if (hoverTimer) { clearTimeout(hoverTimer); hoverTimer = null; }
      hideTooltip();
    }, { passive: true });
  });


  document.addEventListener('focusin', (e) => {
    const cell = e.target.closest && e.target.closest('td.title, th.title');
    if (!cell) return;
    const isOverflowing = cell.scrollWidth > cell.clientWidth;
    if (!isOverflowing) return;
    hoverTimer = setTimeout(() => showTooltipFor(cell), 350);
  });

  document.addEventListener('focusout', (e) => {
    if (hoverTimer) { clearTimeout(hoverTimer); hoverTimer = null; }
    hideTooltip();
  });
})();
</script>

</body>
</html>
